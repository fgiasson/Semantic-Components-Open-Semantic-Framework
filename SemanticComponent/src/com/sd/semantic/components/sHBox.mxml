<?xml version = "1.0" encoding = "utf-8"?>

<!---
  The sHBox semantic component can be used for different purposes. It is primarily used to 
  display information about specific records. In this case, we talk about a record box: a 
  canvas where we display all information relative to a target record.
  
  In other cases, it is used as a display container that has some additional behavior with 
  the required attribute of each of its child semantic component. 
  
  @author Frederick Giasson, Structured Dynamics LLC.
-->

<mx:HBox xmlns:mx = "http://www.adobe.com/2006/mxml" creationComplete="init()" width="100%" height="100%" styleName="sHBox">
  <mx:Script>
    <![CDATA[
      import com.sd.semantic.core.Namespaces;
      import com.sd.semantic.utilities.*;
      import com.sd.semantic.core.Resultset;

    /** Core varibles shared amongst all semantic controls */
    
    /** 
     * Specifies that this component is a semantic component. If a component in a Flex application is a semantic
     * semantic component, this means that other semantic component can't behave differently depending of the "kind"
     * (semantic or not) of components that are present in the layout. This variable is just to specify is a component
     * is a semantic one or not.
     */
    public var semanticComponent:Boolean = true;
    
    /**
     * Specifies that this control is required within a display cluster.
     * This means that if we have a SemanticHBox that has 2 required semantic
     * components and that these components have removed themselves from the display
     * this means that the parent layout cluster (the smeantic hbox), will remove
     * itself as well. If a semantic component is marked as not required (required=false)
     * it means that it won't be considered by the semantic hbox. So, even if such a semantic
     * component has data in it, its parent cluster can remove itself.
     */
    public var required:Boolean = true;
    
    /**
     * The recordBox attribute specifies if the HBox contains all the controls
     * to display information about a complete record. This mainly used
     * to manage the "GenericBox" generic content attribute display control.
     */
    public var recordBox:Boolean = false;
    
    /** Target record attributes to display in the component */
    public var targetAttributes:Array = [];
    
    /** Target record types to display in the component */
    public var targetTypes:Array = [];
    
    /** Specifies if the sControl's targetAttribute has been bound to a know semantic control. */
    public var bound:Boolean = false;      
    
    private var _semanticDataProvider:Resultset;
    
    /** Input records. This is a Resultset structure (see the structXML XML data structure) */
    public function get semanticDataProvider():Resultset
    {
      return (_semanticDataProvider);
    }      
    
    public function set semanticDataProvider(value:Resultset):void
    {
      _semanticDataProvider = value;
    }
    
    /**
     * The recordBox attribute specifies if the HBox contains all the controls
     * to display information about a complete record. This mainly used
     * to manage the "GenericBox" generic content attribute display control.
     */
    public var isRecordBox:Boolean = false;

    private function init():void
    {
      /** Child controls of the HBox */
      var children:Array = [];
      
      SemanticUtils.getChildrenRecur([this], children);

      /** Specifies if the HBox should remove itself from the application layout */
      var removeSelfControl:Boolean = true;

      /** 
      * Check all the children (recursively) of the sHBox are not-require. If all children are not
      * required, the sHBox will delete itself from the layout.
      * 
      * This mechanism is used in case that a developer defined a sHBox with few components
      * and that none of them get bounded to any attribute/value. In such a case, these components
      * delete themselves from the layout, and leave this empty sHBox. It is at init time that
      * this box will remove itself from the layout if such a thing happen.
      * 
      * This is part of the adaptive interface feature of the Semantic Componet framework.
      */  
      for(var i:int = 0; i < children.length; i++)
      {
        /** 
        * Since getChildrenRecur include the target parent components in its resultset, we
        * have to make sure to script those (in this case, the HBox) so that we don't
        * consider it in the process bellow.
        */
        if(children[i] == this)
        {
          continue;
        }
        
        /**
         * A special usecase is when the child is a sControl, and that the child embeded in the sControl removed itself
         * from the layout. In this case, the sControl become empty and has to be removed even if it is marked as
         * "required".
         */
        if(children[i] is sControl && children[i].numChildren == 0)
        {
          this.removeChild(children[i]);
          continue;
        }
        
        /** Check if the child "i" is required or not in the layout */
        if(children[i].hasOwnProperty("required"))
        {
          if(children[i].required == true)
          {
            removeSelfControl = false;
            break;
          }
        }
        else
        {
          /** 
          * A semantic control by default is required. So if the "required"
          * attribute is not defined, we assume it is required
          */
          if(children[i].hasOwnProperty("semanticComponent"))
          {
            removeSelfControl = false;
            break;
          }
        }
      }

      /** Remove the sHBox if no required components are defined as a child of this box */
      if(removeSelfControl == true)
      {
        this.parent.removeChild(this);
      }

      /** Check if the HBox is a recordBox */
      if(isRecordBox == true && semanticDataProvider != null)
      {
        children = new Array();

        /** Get all children control */
        SemanticUtils.getChildrenRecur(this.getChildren(), children);

        /** Check if a GenericBox has been defined for this recordBox */
        for(i = 0; i < children.length; i++)
        {
          if(children[i] is sGenericBox)
          {
            /** List of all bound variables to these children controls */
            var bAttributes:Array = SemanticUtils.getBoundAttributes(children);

            /** List of all unbound variables of the record */
            var unboundAttributes:Array = new Array();

            var namespaces:Namespaces = new Namespaces();
            
            /** Find all unbound attributes */
            for(var predicateType:String in semanticDataProvider.subjects[0].predicates)
            {
              /** Make sure that the predicate type can match its prefixed and un-prefixed versions. */
              if(bAttributes.indexOf(predicateType) == -1 &&
                 bAttributes.indexOf(namespaces.getVariable(predicateType)) == -1 &&
                 bAttributes.indexOf(namespaces.getNamespace(predicateType)) == -1)
              {
                unboundAttributes.push(predicateType);
              }
            }

            children[i].semanticDataProvider = semanticDataProvider;
            children[i].targetAttributes = unboundAttributes;
              
            /** Generate the sGenericBox component */
            children[i].displayGenericAttributes();

            /** We only process the first GenericBox we encounter */
            break;
          }
        }
      }
    }

    ]]>
  </mx:Script>
</mx:HBox>