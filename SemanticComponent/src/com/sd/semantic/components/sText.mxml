<?xml version = "1.0" encoding = "utf-8"?>

<!---
  The first thing a sText check when it gets created is if something has been defined 
  for its "text" variable. If something has been defined, the control tries to find a 
  bound attribute within that text. If a bound(s) attribute(s) have been defined within 
  the value of the "text", but that no value for these attributes have been found in the 
  target record description, the sText remove itself from the application layout.
  
  If the "text" variable is null/empty, or if no bound attribute have been define in the 
  text of the component, we check if targetAttributes have been specified. If no such 
  targetAttributes have been defined, the sText component remove itself from the application 
  layout. 
  
  @author Frederick Giasson, Structured Dynamics LLC.
-->
<mx:Text xmlns:mx = "http://www.adobe.com/2006/mxml" width="100%" height="100%" creationComplete = "init()" styleName="sText">
  <mx:Script>
    <![CDATA[
    import com.sd.semantic.core.Namespaces;
    import com.sd.semantic.core.Resultset;

    /** Core varibles shared amongst all semantic controls */
    
    /** 
     * Specifies that this component is a semantic component. If a component in a Flex application is a semantic
     * semantic component, this means that other semantic component can't behave differently depending of the "kind"
     * (semantic or not) of components that are present in the layout. This variable is just to specify is a component
     * is a semantic one or not.
     */
    public var semanticComponent:Boolean = true;
    
    /**
     * Specifies that this control is required within a display cluster.
     * This means that if we have a SemanticHBox that has 2 required semantic
     * components and that these components have removed themselves from the display
     * this means that the parent layout cluster (the smeantic hbox), will remove
     * itself as well. If a semantic component is marked as not required (required=false)
     * it means that it won't be considered by the semantic hbox. So, even if such a semantic
     * component has data in it, its parent cluster can remove itself.
     */
    public var required:Boolean = true;
    
    /** Target record attributes to display in the component */
    public var targetAttributes:Array = [];
    
    /** Target record types to display in the component */
    public var targetTypes:Array = [];
    
    /** Specifies if the sControl's targetAttribute has been bound to a know semantic control. */
    public var bound:Boolean = false;      
    
    private var _semanticDataProvider:Resultset;
    
    /** Input records. This is a Resultset structure (see the structXML XML data structure) */
    public function get semanticDataProvider():Resultset
    {
      return (_semanticDataProvider);
    }      
    
    public function set semanticDataProvider(value:Resultset):void
    {
      _semanticDataProvider = value;
      
      /** If the value of the data provider changes, we re-initialize the sImage control. */
      if(_initialized) /** Make sure the control has been initialized a first time */
      {
        init();
      }
    }
    
    /** Specifies what attribute(s) of a record have been bound to this semantic component */  
    public var boundAttributes:Array = new Array();

    /** Specifies if the component has already been initialized or not. */
    private var _initialized:Boolean = false;
      
    /** Initialize the sText component with a new text string to display */
    private function init():void
    {
      var checkForTargetAttributes:Boolean = false;
      
      /** 
      * If something is accessible to the "text" attribute of this text component,
      * we try to find if a variable has been bound to it
      */
      if(text != null && text != "")
      {
        /** Check if some variables have been bound in the text string. */
        var textVars:Array = text.match(/\[\[.*\]\]/);
  
        if(textVars != null && textVars.length > 0)
        {
          var undefinedVar:int = 0;
  
          for(var i:int = 0; i < textVars.length; i++)
          {
            var boundVar:String = textVars[i];
  
            /** Remove the "[[" and "]]" markup from the string */
            boundVar = boundVar.substr(2, boundVar.length - 4);
            
            /** 
            * We add the bound variables in the targetAttributes array. We consider that these bound
            * variables are in fact targetAttributes defined by the user.
            */
            targetAttributes.push(boundVar);
  
            /** Keep track of the attributes, from the record, that have been bound to this control. */
            boundAttributes.push(boundVar);
  
            var namespaces:Namespaces = new Namespaces();
            
            var valueFound:Boolean = false;
            
            /** Check if we have something defined for this bound variable */
            if(semanticDataProvider != null && semanticDataProvider.subjects.length > 0)
            {
              for(var predicateType:String in semanticDataProvider.subjects[0].predicates)
              {
                if(boundVar == predicateType || boundVar == namespaces.getVariable(predicateType) || boundVar == namespaces.getNamespace(predicateType))
                {
                  text = text.replace("[[" + boundVar + "]]", semanticDataProvider.subjects[0].getPredicateValues(predicateType)[0]["value"]);
                  valueFound = true;
                  break;
                }
              }
            }
            
            if(valueFound == false)
            {
              /** If we don't, we simply replace the variable by an empty string in the text. */
              text = text.replace("[[" + boundVar + "]]", "");
              undefinedVar += 1;
            }
          }
  
          /** 
          * The rule here is that if no bound variable have any value, we
          * simply delete the control.
          */
          if(undefinedVar == textVars.length)
          {
            this.parent.removeChild(this);
            return;
          }
        }
        else
        {
          checkForTargetAttributes = true;
        }  
        
      }
      else
      {
        checkForTargetAttributes = true;
      }
      
      /** Check if targetAttributes have been defined for this component */
      if(checkForTargetAttributes)
      {
        var noTargetAttributeValue:Boolean = true;
        
        if(targetAttributes.length > 0)
        {
          for each(var attribute:String in targetAttributes)
          {
            if(semanticDataProvider != null && semanticDataProvider.subjects.length > 0)
            {
              var values:Array = semanticDataProvider.subjects[0].getPredicateValues(attribute);
              
              if(values.length > 0)
              {
                /** we simply display the first value of the first target attribute */
                if(values[0]["value"] && values[0]["value"] != "")
                {
                  this.text = values[0]["value"];
                  noTargetAttributeValue = false;
                  break;
                }
              }
            }            
          }
        }
        
        if(noTargetAttributeValue)
        {
          this.parent.removeChild(this);
          return;
        }
      }
      
      _initialized = true;
    }

    ]]>
  </mx:Script>
</mx:Text>